everything is done BY POINTER, always. the generator takes care of transforming values or reference to a pointer


typemap operators
-----------------

check: verify that a script object can be converted to a C object
to_c: convert a script object to a C object
from_c: convert a C object to a script object






Lua:

typemap signatures
------------------

check: bool check(lua_State *L, int idx);
to_c: int to_c(lua_State *L, int idx, c_type *val);
from_c: int from_c(lua_State *L, c_type *val); // return the number of values pushed onto the stack














#--------------


struct simple_struct {
	int a;
};



// from_C
simple_struct simple_struct_by_value(); // construct by copy and own
const simple_struct simple_struct_by_value(); // construct by copy and own

simple_struct *simple_struct_by_pointer(); // store by address and do not own
simple_struct &simple_struct_by_reference(); // store by address and do not own
const simple_struct *simple_struct_by_pointer(); // store by address (immutable) and do not own
const simple_struct &simple_struct_by_reference(); // store by address (immutable) and do not own


we need to:

- create and wrap T from script (with correct ownership)
- pass T to C
- pass T from C and wrap in script (with correct ownership)

















// VM dependent code (MINIMIZE ON THIS!)










int from_c(lua_State *L, void *obj, const char *type, OwnershipPolicy policy)
{
	switch (policy) {
		default:
		case NonOwning:
			return _wrap_obj<NativeObjectPtrWrapper<type>>(L, obj);
		case ByValue:
			return _wrap_obj<NativeObjectValueWrapper<type>>(L, obj);
		case ByAddress:
			return _wrap_obj<NativeObjectUniquePtrWrapper<type>>(L, obj);
	}
	return 0;
}






// shared_ptr


int from_c(lua_State *L, void *obj, const char *type, OwnershipPolicy policy)
{
	return _wrap_obj<NativeObjectSharedPtrWrapper<type>>(L, obj); // ignore policy
}


